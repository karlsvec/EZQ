#!/usr/bin/env ruby

# Download the ref'd files all through except the get_yield_map_path refd here:
# yield": {
#               "id": 109,
#               "get_yield_map_path": "/yields/yield_maps/000/000/109/original/Jellum_2013.zip"

# Pull out the map_coords_as_geojson element for each MZ, and write each to
# MZ_id.geojson (id tag in each MZ is an integer) and dump it in same dir
# as full field geojson, which refd in top-level tag geojson_file
# So, you'll have as many of these files as there are management zones.

# Pass the entire input doc that we're parsing here into the C++ app.


# unit_id = 1 is $/ac
# unit_id = 2 is $/bu

# C++ app will return processed images that can be input to qgis,
# along with json doc or docs detailing yield info that I can combine with
# Commodity price to get Revenue for a field/zone.

# Question: when do I want to do the qgis stage:
#  1. All at once
#  2. Just before each image is needed
#
# Best to figure out how I want report workflow to go.
# 1. Each section will be generated by a separate function
# 2. Sections that are generated multiple times will take care of own iteration,
#    but will essentially use an outer loop that iterates over the bulk of the
#    function body so that variables passed into the erb keep the same names
#    and the erb doesn't have to reference an index into a sub-hash each time.
# 3. Given these two, it makes sense to do the qgis in a single batch and
#    set image refs as variables rather than static names. Single batch
#    processing would also allow us to spawn multiple instnaces of the python
#    script that does the qgis work.



def get_reqs
  require 'json'
  require 'yaml'
  require 'set'
  require '../ezqlib'
  #require_relative '../ReportHandler/remove_blank_pages'
end



# Convert an Integer or Float to x.yy currency
def curr(v)
  return "%.2f" % v.to_f
end



# Gets all the files from S3 that we'll need based on refs in the input json.
# @param [Hash] input The input hash containing appropriate file refs.
# @return [Bool] true if all file gets succeeded; false otherwise
def get_files(input)
  bucket = 'roi.agsolver'
  keys = Set.new()
  keys << input['geojson_file']
  input['scenarios'].each do |scenario|
    keys << scenario['get_tiff_raster_path']
    keys << scenario['get_yield_json_file_path']
  end
  successes = keys.to_a.map{|key| EZQ.get_s3_file(bucket,key)}
  return successes.reduce(:&)
end



# Pulls map coords for each management zone from input and writes each
# set to a file named MZ_[id].geojson.
# @param [Hash] input The input hash containing management zones
# @return [nil] Side effects only; always returns nil.
def write_mz_coords(input)
  path = File.dirname(input['geojson_file'])
  input['scenarios'].each do |scenario|
    scenario.fetch('management_zones',[]).each do |mz|
      fname = "#{path}/MZ_#{mz['id']}.geojson"
      coords = mz['map_coords_as_geojson']
      File.write(fname,coords)
    end
  end
  return nil
end



# Run the binary that processes the input json and all the images.
# @return [Bool or nil] true, false, or nil as per EZQ.exec_cmd
def run_binary(input)
  return EZQ.exec_cmd("run_the_thing #{input.to_json.dump}")
end



def make_maps(input)
  in_dir = 'img_in'
  out_dir = 'report_images'

  # A bunch of calls to the agmap script will go here. This kind of thing:
  # Generate musym map
  #system("DISPLAY=:0 python agmap.py" +
  #       " --maptype=musym" +
  #       " --output=\"#{out_dir}/musym.png\"" +
  #       " --input=\"#{in_dir}/#{job_id}_#{record_id}.geojson\"" +
  #       " --autofit=exact")

end



def make_profit_histogram(xml_file)
  # TODO: Re-work the hist.rb from SRC reporthandler to deal with this case.
  # Even better, modify it with another layer so that the same core class can
  # be re-used.
  return EZQ.exec_cmd("ruby hist.rb #{xml_file}")
end



def make_expenses_pie_chart(budget_items,out_file)
  sb = sort_budget(budget_items)
          .delete_if{|it| ['Commodity Price','Other Revenue'].include?(it['item_name'])}
  values = sb.map{|bi| bi['amount']}
  labels = sb.map{|bi| bi['item_name']}
  labels = labels.map{|t| t.gsub(/\//,"/\n")}
  return EZQ.exec_cmd(['python', 'pie_chart.py',out_file,labels.to_s,values.to_s])
end


################################################################################
# each of these needs to return the name of the file it generated

def make_yield_data(data)
  d = data.clone
  d[:yield_map] = ''# This will reference a file output by qgis
  return generate_html('template/yield_data.html.erb',
                       'report/yield_data.html')
end



def make_applied_fertilizer(data)
  d = data.clone
  return generate_html('template/applied_fertilizer.html.erb',
                       'report/applied_fertilizer.html')
end



def make_applied_planting(data)
  d = data.clone
  return generate_html('template/applied_planting.html.erb',
                       'report/applied_planting.html')
end



def make_yield_by_soil(data)
  d = data.clone
  return generate_html('template/yield_by_soil.html.erb',
                       'report/yield_by_soil.html')
end



def make_overall_profit(data)
  d = data.clone

  # !!!!! Somehow this will come in from Doug
  field_yield = 1
  d[:field_revenue] = calculate_revenue(d[:scenario_budget],field_yield,d[:field_area])
  d[:field_expenses] = calculate_expenses(d[:scenario_budget])
  d[:field_profit] = d[:field_revenue] - d[:field_expenses]
  d[:field_profit_per_acre] = d[:field_profit] / d[:field_area]

  # !!!!! Some calculation?
  d[:field_roi] = 1

  return generate_html('template/overall_profit.html.erb',
                       'report/overall_profit.html')
end



def make_zone_profit(data,zone)
  d = data.clone
  mz = zone.clone

  d[:mz_name] = mz['name']
  d[:mz_id] = mz['id']
  d[:mz_area] = mz['get_area_in_acres']

  # !!!!! Somehow this will come in from Doug
  zone_yield = 1
  d[:mz_revenue] = calculate_revenue(zone['budget'],zone_yield,d[:mz_area])
  d[:mz_expenses] = calculate_expenses(zone['budget'])
  d[:mz_profit] = d[:mz_revenue] - d[:mz_expenses]
  d[:mz_profit_per_acre] = d[:mz_profit] / d[:mz_area]

  # !!!!! Some calculation?
  d[:mz_roi] = 1

  d[:mz_year] = d[:scenario_budget]['name']
  return generate_html('template/zone_profit.html.erb',
                       "report/zone_#{d[:mz_id]}_profit.html")
end



def make_overall_revenue_and_expenses(data)
  d = data.clone

  set_overall_expense_revenue_vars(d)
  return generate_html('template/overall_profit.html.erb',
                       'report/overall_profit.html')
end



def make_revenue_and_expenses_with_zones(data,zone)
  d = data.clone
  mz = zone.clone

  d[:mz_name] = mz['name']
  d[:mz_area] = mz['get_area_in_acres']

  # Originally we were doing a table with total field values next to zone values
  # We're no longer doing that, so could replace this with something that just
  # sets d[:commodity_price]. Leaving the full thing here for now in case we go
  # back to the othe way.
  set_overall_expense_revenue_vars(d)

  # !!!!! Somehow this will come in from Doug
  d[:mz_avg_yield] = 1
  d[:mz_revenue] = d[:commodity_price] * d[:mz_avg_yield]
  d[:mz_expenses] = calculate_expenses(zone)
  d[:mz_other_revenue_per_acre] = zone['budget_items']
          .select{|bi| bi['item_name'] == 'Other Revenue'}
            ['amount']
  d[:mz_revenue_per_acre] = d[:mz_revenue] / d[:mz_area]
                              + d[:mz_other_revenue_per_acre]
  d[:mz_expenses_per_acre] = d[:mz_expenses] / d[:mz_area]
  d[:mz_profit_per_acre] = d[:mz_revenue_per_acre]
                             - d[:mz_expenses_per_acre]
  d[:mz_budget_exp] = sort_budget(zone['budget']['budget_items'])
          .delete_if{|it| ['Commodity Price','Other Revenue'].include?(it['item_name'])}
  return generate_html('template/revenue_and_expenses_with_zones.html.erb',
                       'report/zone_#{d[:mz_id]}_revenue_and_expenses.html')
end
################################################################################



def calculate_revenue(budget,yld,area)
  items = budget['budget_items']
  commodity_price = items.select{|bi| bi['item_name'] == 'Commodity Price'}['amount']
  return commodity_price * yld
    + items.select{|bi| bi['item_name'] == 'Other Revenue'}['amount'] * area
end



def calculate_expenses(budget)
  revenues = ['Commodity Price','Other Revenue']
  return budget['budget_items'].select{|bi| !revenues.include?(bi['item_name'])}
                    .map{|i| i['amount']}.reduce(:+)
end


def set_overall_expense_revenue_vars(d)
  d[:commodity_price] = d[:scenario_budget]['budget_items']
              .select{|bi| bi['item_name'] == 'Commodity Price'}
                ['amount']
  # !!!!! Somehow this will come in from Doug
  d[:field_avg_yield] = 1
  d[:field_revenue] = d[:commodity_price] * d[:field_avg_yield]
  d[:field_expenses] = calculate_expenses(d[:scenario_budget])
  d[:other_revenue_per_acre] = d[:scenario_budget]['budget_items']
          .select{|bi| bi['item_name'] == 'Other Revenue'}
            ['amount']
  d[:total_revenue_per_acre] = d[:field_revenue] / d[:field_area]
                               + d[:other_revenue_per_acre]
  d[:total_expenses_per_acre] = d[:field_expenses] / d[:field_area]
  d[:total_profit_per_acre] = d[:total_revenue_per_acre]
                              - d[:total_expenses_per_acre]
  # We want a sorted budget that includes only expenditures
  d[:budget_exp] = sort_budget(d[:scenario_budget]['budget_items'])
          .delete_if{|it| ['Commodity Price','Other Revenue'].include?(it['item_name'])}
  return nil
end



# Run erb to expand template in_file and write the html result to out_file
# @return Returns the value passed in as parameter out_file
def generate_html(in_file,out_file)
  pwd = Dir.pwd()
  # Changing into in_file's directory ensures that all relative
  # paths mentioned in in_file work properly
  Dir.chdir(File.dirname(in_file))
  erbed = ERB.new(File.read(File.basename(in_file)))

  Dir.chdir(pwd)
  File.write(out_file,erbed.result)

  return out_file
end



# def hash_budget(budget_items,area)
#   new_bud = {}
#   return new_bud if !budget_items
#   # This needs to re-sort based on item_id. Might need to use array instead of hash.
#   budget_items.each do |bi|
#     bi['total'] = bi['amount'] * area if bi['unit_id'] == 1
#     commodity_price = bi['amount'] if bi['unit_id'] == 2
#     new_bud[bi['item_name']] = {:amount=>bi['total'],:itemized=>hash_budget(bi['sub_budget_items'],area)}
#     new_bud[bi['item_name']][:units] = bi['unit_id'] == 1 ? '$/ac' : '$/bu'
#   end
#   return new_bud
# end


# Sort the budget items by item_id so they can be displayed in the correct order
# with minimal fuss in the erb
def sort_budget(budget_items)
  return budget_items.sort_by{|it| it['item_id']}
end



def set_vars(input)
  j = input
  d = {}
  d[:field_name] = j['field_name']
  d[:field_area] = j['field_area']
  d[:scenario_name] = j['name']
  d[:scenario_budget] = j['budget']
  #d[:year] = j['budget']['year'] # no such key. The year appears be scenario_name

  # do whatever to flatten budget info into required form

  return d
end



def run
  get_reqs()
  AWS.config(YAML.load_file('../credentials.yml'))
  input = JSON.parse(File.read('field50pp.json'))
  #get_files(input)
  #write_mz_coords(input)
  #run_binary(input)
  #make_maps(input)

  reports = []
  scenario_ids = []
  input['scenarios'].each do |scenario|
    scenario_ids << scenario['id']

    # Add the field name and area into the top level of each scenario since
    # those values are needed for display in a few different places.
    scenario['field_name'] = input['name']
    scenario['field_area'] = input['get_area_in_acres']
    d = set_vars(scenario)

    pdfs = []
    # Make report sections for this scenario
    pdfs << make_yield_data(d)
    pdfs << make_applied_fertilizer(d)
    pdfs << make_applied_planting(d)
    pdfs << make_yield_by_soil(d)
    pdfs << make_overall_profit(d)
    pdfs << make_overall_revenue_and_expenses(d,scenario)

    scenario['management_zones'].each do |mz|
      pdfs << make_zone_profit(d,mz)
      pdfs << make_revenue_and_expenses_with_zones(d,mz)
    end


    report_name = ''  #  <~ Need to come up with naming scheme.

    # Stitch the report pieces into one pdf
    #system("gs -dBATCH -dNOPAUSE -q -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -sOutputFile=#{report_name} #{pdfs.join(' ')}")

    # Reject blank pages in the pdf. Set option :y to the same number as
    # .logo{max-height} from main.css for now.
    #RemoveBlankPages.remove(report_name,{:y=>100})
    reports << report_name
  end

  # Send reports to S3 and send back message with location, or email, or
  # whatever happens here
end




def test
  # This is just for development in LightTable, since somehow my path gets munged:
  Dir.chdir('/home/penn/EZQ/pzm_reportmaker')

  get_reqs()
  input = JSON.parse(File.read('field50pp.json'))

  #get_files(input)

  #puts input['scenarios'][0]['budget']['budget_items']
  #puts make_expenses_pie_chart(input['scenarios'][1]['budget']['budget_items'],'pie_test.png')
end

test
